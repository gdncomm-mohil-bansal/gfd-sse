package com.gfd_sse.dummyoff2onredis.controller;

import com.gfd_sse.dummyoff2onredis.service.OTPService;
import com.gfd_sse.dummyoff2onredis.service.SSEService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

@RestController
@RequestMapping("/api/sse")
@CrossOrigin(origins = "*")
public class SSEController {

    private static final Logger logger = LoggerFactory.getLogger(SSEController.class);

    private final SSEService sseService;
    private final OTPService otpService;

    public SSEController(SSEService sseService, OTPService otpService) {
        this.sseService = sseService;
        this.otpService = otpService;
    }

    /**
     * Establish SSE connection with OTP authentication
     * GFD PWA will connect to this endpoint with userId and OTP
     */
    @GetMapping(value = "/connect", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public ResponseEntity<?> connect(
            @RequestParam String userId,
            @RequestParam String otp) {

        logger.info("SSE connection request from user: {} with OTP: {}", userId, otp);

        try {
            // Validate input
            if (userId == null || userId.trim().isEmpty()) {
                logger.warn("SSE connection rejected: Missing userId");
                return ResponseEntity.badRequest()
                        .body("User ID is required");
            }

            if (otp == null || otp.trim().isEmpty()) {
                logger.warn("SSE connection rejected for user {}: Missing OTP", userId);
                return ResponseEntity.badRequest()
                        .body("OTP is required");
            }

            // Validate OTP from Redis (generated by dummy-off2on)
            String validatedUserId = otpService.validateAndGetUserId(otp);
            if (validatedUserId == null) {
                logger.warn("SSE connection rejected: Invalid or expired OTP");
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                        .body("Invalid or expired OTP. Please generate a new OTP from Front-liner app.");
            }

            // Verify userId matches
            if (!validatedUserId.equals(userId)) {
                logger.warn("SSE connection rejected: UserId mismatch. Expected {}, got {}",
                        validatedUserId, userId);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                        .body("User ID does not match OTP.");
            }

            // Check if user already has an active connection
            if (sseService.hasActiveConnection(userId)) {
                logger.info("User {} already has an active connection. Closing old connection.", userId);
                sseService.removeEmitter(userId);
            }

            // Create SSE emitter
            SseEmitter emitter = sseService.createEmitter(userId);

            // Invalidate OTP after successful connection (one-time use)
            otpService.invalidateOTP(otp);

            logger.info("SSE connection established successfully for user: {}", userId);
            return ResponseEntity.ok(emitter);

        } catch (Exception e) {
            logger.error("Error establishing SSE connection for user: {}", userId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Failed to establish SSE connection: " + e.getMessage());
        }
    }

    /**
     * Disconnect SSE connection
     */
    @PostMapping("/disconnect/{userId}")
    public ResponseEntity<String> disconnect(@PathVariable String userId) {
        logger.info("Disconnect request for user: {}", userId);

        try {
            sseService.removeEmitter(userId);
            return ResponseEntity.ok("SSE connection closed successfully");
        } catch (Exception e) {
            logger.error("Error disconnecting user: {}", userId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Failed to disconnect: " + e.getMessage());
        }
    }

    /**
     * Check connection status
     */
    @GetMapping("/status/{userId}")
    public ResponseEntity<String> checkStatus(@PathVariable String userId) {
        boolean isConnected = sseService.hasActiveConnection(userId);
        String status = isConnected ? "Connected" : "Not connected";
        return ResponseEntity.ok(status);
    }

    /**
     * Get active connection count
     */
    @GetMapping("/connections/count")
    public ResponseEntity<Integer> getConnectionCount() {
        int count = sseService.getActiveConnectionCount();
        return ResponseEntity.ok(count);
    }
}
